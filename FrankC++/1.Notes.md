
# Writting our first Program

It is very common for your first coding problem to be "Hello World." This is basically the simplest program you write at first to get an introduction to the code syntax and become familiar with how to "run" programs. Below is a simple "hello world" for c++.

```c++
#include <iostream>

int main(){
    
    std::cout << "Hello World" <<std::endl;
    return 0;
}
 
```

The general C++ process is:

1. Code - write the program.
2. Save - save the program.
3. Compile - compile via terminal.
    * typically done using the `g++ <file_name>` command.
    * this produces a file called `a.out`.
    * Next, we run the `a.out` file which is now machine code using `./a.out`.
4. Execute - execute via terminal.

We can name the output executable file by using the command `g++ hello.cpp -o hello`.

Now, our executable file can run using `./hello`.

NOTE: For my Mac I use `g++ -std=c++11 <filename>`.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

int main() {

    /* Creating variable to store user input*/
    int favorite_number; 

    /* Prompt user to enter their favorite number */
    std::cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    std::cin >> favorite_number;

    /* Responde back to user */
    std::cout << "Nice! That's my favorite number too! " <<std::endl;

    return 0;
}
```

Code Breakdown:

* `# include <iostream>` is needed because we need to use the input/output library. This allows the compiler to understand what `cout` and `cin` mean.
* all c++ programs must have ONE `int main()` function.
* `std::endl` is used to move the cursor to a new line after execution.

## Note

When trying to run this program, I wasn't able at first to input my favorite number. This issue as well as "how do I run this?" are addressed in this [video](https://www.youtube.com/watch?v=KhGnYWplLVo&ab_channel=TechDecodeTutorials)

# Common Errors

## What are Compiler Errors?

1. Syntax Errors: Something is wrong with your code structure.
2. Semantic Errors: Something is wrong with your logic.

In Visual Studio Code, the section "Problems" will help catch these Syntax Errors since it is actively scanning your code and checking to see you are following the conventions/rules.

## What are Compiler Warning?

Same as above, Visual Studio Code has the section called "Problems" that shows you any errors/warnings in real time so that you can fix them BEFORE you run your program. However, the difference here is that the compiler can still compile your code so it's not an error but rather a warning.

Most common, you might see compiler waning about "uninitialized" variables. This just means, you forgot to define what that variable value is. For example, the code below is going to print `favorite_number` but I never define what `favorite_number` is so, we get a compiler warning.

## "Uninitialized Variable" Compiler Warning

```c++

#include <iostream>

int main() {

    int favorite_number; 

    std::cout << favorite_number << std::endl;

    return 0;
}
```

When we run this, the terminal shows favorite_number =`176267360` which is just some random number that was compiled.

## "set but not used" Compiler Warning

You can also define a variable, give it a value but then forget to use it. This is also another common type of compiler warning and it will show up as "<variable_name> set but not used."

```c++
#include <iostream>

int main() {

    int favorite_number; 
    favorite_number = 1000;

    std::cout << "Hello World!" << std::endl;

    return 0;
}
```

The main idea and philosphy behind compiler warnings is that you should have none after you compile your code.

## What are Linker Errors?

Typically, this error occurs when a libary or object file is missing.

Think of this scenario:

* You need file_1, file_2 and file_3 to run your program.

If file_3 references something that is in file_1 or file_2 but they are deleted then you will most likely get a Linker Error.

## What are RunTime Errors?

Errors that occur when the program is executing.

Common RunTime Errors:

* Divide by Zero
* File note Found
* Out of Memory

You typically handle these errors by using `Exception Handling` which is a way to "anticipate" an error and give your program instructions on how to handle an error that might occur.

## What are LogicErrors?

LogicErrors are errors/bugs in your code that cause your programm to run incorrectly. This type of error is caused by the Programmer's logic, how you are trying to solve the problem presented.

# Structure of a C++ Program

## Basic Components (Basic Components create syntax)

* C++ has defined "keywords" which are reserved for the program. This means they are not available for re-defining and/or overloading.

* The `>>` and `<<` are called chevron keys.
* `>>` is called the "string extraction" operator; it takes something from the console and stores it to a variable.
* `<<` is called the "string insertion" operator. We insert whatever is on the right hand side to whatever is on the left.
* `::` is called the scope resolution operator.

## Preprocessor Directives

Preprocessor directives perform preliminary operations on C++ files before they are passed to the compiler. Some use-case examples are inserting files, specifying compile-time error message, defining conditional compilation conditions based on OS etc.

## The Main Function

The `main()` function must always return an integer. A zero 0 is returned when the program runs sucessfully.

The `main()` function represents the starting point of our program execution.

## Namespace

Namespace: the variables defined in C++; "standard variables" means they already have a specific meaning. For example, `cout` means "c out".

`std` is the name for the standard C++ namespace.

So, we know we can use `std::cout <<"Hello World" << std::endl;` to print out "Hello world" in the terminal. But what if we wanted to define our own `cout` function?

`baker::cout`

Now, C++ will be confused because there are two `cout` functions being called. This is why we use `std::` because we are telling the compiler "use the standard namespace that C++ knows when you run the cout function."

`::` this is called the "scope resolution operator" because it's used to define what scope the compiler should use when reading variables/commands.

We can explicitly define what namespace we want the compiler use by defining it before our main() function. This is called using the "namespace directive." For example:

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using namespace std;

int main()
{

    /* Creating variable to store user input*/
    int favorite_number;

    /* Prompt user to enter their favorite number */
    cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    cin >> favorite_number;

    /* Responde back to user */
    cout << "Nice! That's my favorite number too! " << endl;
    cout << "No really! " << favorite_number << " is my favorite number! " << endl;

    return 0;
}
```

This lets us type less and makes the code a little bit easier to read.

However, using the namespace directive bring in EVERYTHING from the `std` (standard namespace) so, more often we will see individual namespaces declared. This means you only declare "what" from the standard namespace you want to the compiler to reference.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 standard scope resolutions
using std::endl;

int main()
{

    /* Creating variable to store user input*/
    int favorite_number;

    /* Prompt user to enter their favorite number */
    cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    cin >> favorite_number;

    /* Responde back to user */
    cout << "Nice! That's my favorite number too! " << endl;
    cout << "No really! " << favorite_number << " is my favorite number! " << endl;

    return 0;
}
```

## Comments

Comments need to add meaning; do not state the obvious. Before writting comments ask yourself "is this providing any value?" Once thing to note is that comments never make it to the compiler. Preprocessors strip out comments so compiler never sees them. Think about this, why?

Well, comments are for humans, so the compiler does not need this "for human" code in order to compile.

Type of comments:

1. Single Line comments: `// This is an inline comment.`

2. Multiline Comment: `/* */`

## Basic I/O

I/O stands for Input/Output.

* We output to the console using `cout <<`.
  * anything on the right of `cout <<`  is sent to the console.
  * ex. `count << "Hello World";`
  * We can "chain" `cout`; we saw this in the "enter your favorite number" example.
  * ex. `cout << "No really! " << favorite_number << " is my favorite number! " << endl;`
  * Why do we commonly see `endl`? because line breaks are not automatically added
* We input (take in) information from the user using `cin >>`.
  * The information that is inputted is saved to the variables on the right of `cin >>`.
  * This process can also be chained. `cin >> data1 >> data2` This means, whatever is typed in the keyboard is going to be stored in both data1 and data2.
  * We can get fails if the information being inputted is not the type we expected (defined).

A simple example of I/O (Input/Output) is asking for two numbers and storing them.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{

    int number1;
    int number2;

    cout << "Enter a number from 1 - 100: ";

    cin >> number1;

    cout << "Enter another number from 1 - 100: ";

    cin >> number2;

    cout << "You entered " << number1 << " and " << number2 << endl;

    return 0;
}
```

We can also see how c++ ignores whitespace by taking in both numbers at the same time.

So now, when we enter "12 23" 12 will be assigned to `number1` and 23 will be assigned to `number2`. All in one command! Keep in mind that the space between 12 and 23 is important because c++ compiler looks for it to see where your favorite number/input starts and ends.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{

    int number1;
    int number2;

    cout << "Enter two numbers from 1 - 100 seperated by a space: ";

    cin >> number1 >> number2;

    cout << "You entered " << number1 << " and " << number2 << endl;

    return 0;
}
```

# Variables and Constants

## What are variables?

* Variables are abstractions for a memory location.
* In Python, we've seen how a variable is simply a memory locations; the same applies in C++.
* All variables must have a type and value.
* IMPORTANT: variables must be declared before they are used. (This is called static typing)

Static Typing:
    A coding language where VARIABLE TYPES are known at compile time.

```c++
#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{
    int number1;
    number1 = 23;
    return 0;
}
```

Compare the code above with this example:

```c++
#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{
    number1 = 23;
    return 0;
}
```

Here, we will get a compiler error becuase we didn't define the variable `type`. The compiler doesn't know if numer1 is suppose to be a character, integer, float etc. In other coding languages, this is not the case. In Python, we can simply declare `age = 23` but not in C++.

## How to declare and initialize a variable

Each variable is created using `VariableType VariableName;`.

What kind of variable types exist?

1. integer `int`
2. double `double` (decimal numbers)
3. string `string` (text)
4. Object Orriented Variables `OOP_Var` ex. `Person`, `Account`

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Enter the width of the room: ";
    int room_width;
    cin >> room_width;

    cout << "Enter the length of the room: ";
    int room_length;
    cin >> room_length;

    cout << "The area of the room is: " << room_width * room_length << " square feet" << endl;

    return 0;
}
```

## Primitive Data Types

* The `char` (character) data type must use single quotes when declaring. `char middle_initial = 'J';`
* `unsigned int` are positive numbers and zero.
* `float` data type will hold decimal numbers.
* `double` is for large decimal numbers.
* `long double` is for numbers that use `e` powers.
* `bool` is for True/False values. `True = 1`; `False = 0`.

Note: In C++, if we aren't using C++11 compiler or newer, we will not see overflow errors and instead get inaccurate integer representations.

Overflow is when a variables being declared does not have enough storage to store the initialized variable. Be careful when doing calculations! Think about two `short * short` integers being multiplied. The answer will not fit into a `short` so we have to declare it using a different data type.

## What is the size of a variable (sizeof)

The `sizeof` operator determines the size in bytes of a type or variable.

`sizeof` uses the `climits` and `cfloat` include files to provide size and precision about our varibles.

```c++
#include <iostream>
#include <climits>
```

## What is a Constant?

Constants are variables that cannot change once declared.

The most common way of declaring a constant is by using the `const` keyword followed by the name of the constant and the value. Constants must be initialized, meaning they must be given their value. For example, `const int months = 12;` shows the constant "months" having the value 12 since there will always be 12 months in a year.

Another "older" way of defining constants is by using `#define` but this is an old way and should no longer be used in Modern c++ compilers.

Here we have an example of a program that uses literal constants:

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Welcome to Baker's Cleaning Service" << endl;

    cout << "\nEnter the number of rooms you want cleaned: ";
    int number_of_rooms;
    cin >> number_of_rooms;

    cout << "\nEstimate of Cleaning Service: " << endl;
    cout << "Number of rooms: " << number_of_rooms << endl;
    cout << "Price per room $" << 30 << endl;
    cout << "Cost $" << 30 * number_of_rooms << endl;
    cout << "Tax $" << 30 * number_of_rooms * 0.06 << endl;
    cout << "==========================" << endl;
    cout << "Total Estimate: $" << (30 * number_of_rooms) + (30 * number_of_rooms * 0.06) << endl;
    cout << "This estimate is valid for " << 30 << " days" << endl;
    return 0;
}
```

Major disadvantages:

1. If you change your price per room you will have to go into the code and change every "30" to a new price.
2. It is harder to maintain and make changes.

Here is an example of the same program using declared constants. Doing this type of change, where you go into your code and make it better to read is called "refactoring." Rememeber, refactoring is simply making your code easier to read. It is not changing the logic etc.

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Welcome to Baker's Cleaning Service" << endl;

    cout << "\nEnter the number of rooms you want cleaned: ";
    int number_of_rooms;
    cin >> number_of_rooms;

    const double price_per_room = 30.0; // use double because maybe you want to charge $30.5 per room 
    const double tax_rate = 0.06;
    const int days_valid = 30; // use int because days will always be whole numbers

    cout << "\nEstimate of Cleaning Service: " << endl;
    cout << "Number of rooms: " << number_of_rooms << endl;
    cout << "Price per room $" << price_per_room << endl;
    cout << "Cost $" << price_per_room * number_of_rooms << endl;
    cout << "Tax $" << price_per_room * number_of_rooms * tax_rate << endl;
    cout << "==========================" << endl;
    cout << "Total Estimate: $" << (price_per_room * number_of_rooms) + (price_per_room * number_of_rooms * tax_rate) << endl;
    cout << "This estimate is valid for " << days_valid << " days" << endl;
    return 0;
}

```

Notice how our `cout` statements are much easier to read and we can follow along and "read" what each statement should be printing out to the console. Also, if we want to change `price_per_room`, `tax_rate` or `days_valid` the change will only have to be made in one place.

### Challenge: Enter the number of small and large rooms and return a total cleaning price

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Welcome to Baker's Cleaning Service" << endl;

    cout << "\nEnter the number of small rooms you want cleaned: ";
    int small_rooms;
    cin >> small_rooms;

    cout << "\nEnter the number of large rooms you want cleaned: ";
    int large_rooms;
    cin >> large_rooms;

    const double small_room_rate = 25.0;
    const double large_room_rate = 35.0;
    const double tax_rate = 0.06;
    const int days_valid = 30;

    cout << "\nEstimate of Cleaning Service: " << endl;
    cout << "Number of small rooms: " << small_rooms << endl;
    cout << "Number of large rooms: " << large_rooms << endl;
    cout << "Price per small room $" << small_room_rate << endl;
    cout << "Price per large room $" << large_room_rate << endl;
    cout << "Cost $" << (small_rooms * small_room_rate) + (large_rooms * large_room_rate) << endl;
    cout << "Tax $" << ((small_rooms * small_room_rate) + (large_rooms * large_room_rate)) * tax_rate << endl;
    cout << "==========================" << endl;
    cout << "Total Estimate: $" << (small_rooms * small_room_rate) + (large_rooms * large_room_rate) + (((small_rooms * small_room_rate) + (large_rooms * large_room_rate)) * tax_rate) << endl;
    cout << "This estimate is valid for " << days_valid << " days" << endl;
    return 0;
}
```

# Arrays and Vectors

The "compound data type" is a type made up of other data types.

## What is an array?

An array is a collection of elements. Where each element can be easily accessed directly.

* IMPORTANT: all elements must be of the same type.

Characteristics of an Array:

* They are fixed size.
* Arrays are contiguously in memory; this mean the memory for this array is allocated in one chunk.
* Elements are accessed via index or poistion. (index starts at 0, -1 index is the last element)

## How to decalre and initialize an Array

The basic anatomy of an array:

`Element_Type array_name [number of elements in the array] = {initializer list};`

For example:

`int test_scores [5] = {90,89,99,87,79};`

Here we are saying "compile an array of integers called test_scores that will hold 5 values and these are the values.

`int high_scores [10] = {35, 75};`

Here we define an array called high_scores that will hold 10 integers but only initialized 2 elements. This means, the remaining elements will be 0's.

`int another_aray [] = {9,3,2,4};`

Here we did not define the array size but because we initialized it the size is automatically calcualted.

## How to access and modify array elements

We start with an array called `test_scores`.

`int test_scores [5]  = {90,85,76,93,99};`

To get the first element of an array we can `cout << "First element: " << test_scores[0];`.

REMEMBER: indexes start at 0 not 1.
So FIRST element is at index 0, second element is at index 1, third element is at index 2....do you see the relationship?

If you want the 23rd ELEMENT you search index 22. (index is always "element you want - 1")

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    int test_scores[5] = {90, 85, 76, 93, 99};

    cout << "The FOURTH ELEMENT in the array is: " << test_scores[3] << endl;
    return 0;
}
```

We can modify an array element by using the same indexing method. For example, let's ask the user to update the SECOND ELEMENT (so index 1) of the test_scores array:

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    int test_scores[5] = {90, 85, 76, 93, 99};

    cout << "The current value of the second elemenent in the test_scores array is: " << test_scores[1] << endl;

    cout << "Enter the new value of the second array element: ";

    cin >> test_scores[1];

    cout << "The new value for test_scores[1] is now: " << test_scores[1] << endl;
    return 0;
}
```

We can also assign elements in our code (not having to ask the user) by using `array_name[index] = new_value`.

## Multidimensional Arrays

The basic syntax to define a multidimensional array is:

`Element_Type array_name [dimension_one][dimension_two];` we can also think of this as
`[number of rows][number of columns]`

We index multidimensional arrays using `[row][column]` indexes.

NOTE: index count starts at 0 for both rows and columns. So the first row is row index 0 and the first column is also index 0.

Therefore, if you want the first element in a multidimensional array you use:
`array_created[0][0]`.

```c++
#include <iostream>
using namespace std;

int main()
{

    int movie_ratings[3][4] = {
        {1, 2, 3, 4},
        {2, 2, 100, 4},
        {5, 6, 8, 2}};

    cout << "The element in the second row, third column is " << movie_ratings[1][2] << endl;

    return 0;
}
```

## Declaring and Initializing Vectors

A vector is simply a "dynamic" array; this just means it can change based on the conditions it runs under. During one run it can contain 5 "things", the next run you can have 100 "things".

Dynamic: something that can change depending on certain conditions. So a vector is just an array that can shrink and grow at execution time.

Pros:

* provides bounds checking so no spillage can occur.
* vectors have lots of useful function such as `sort`, `reverse` and `find`.
* VERY `efficient`.

To start using vectors, we must first declare them using `#include <vector>`. Next, we can declare our vector:
`vector <int> test_scores (5);`.

Here we are declaring a vector called test_scores that will have 5 elements of integer type in it. So, to actually create a vector we can do the following:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    std::vector<int> test_scores = {78, 99, 85, 90, 60};
    cout << "The first element in this vector is: " << test_scores[0] << endl;

    return 0;
}
```

To compile and run we use `g++ -std=c++11 run.cpp` and then `./a.out`.

We can also declare and initialize a vector using `vector <double> high_temps (10, 85.0);`. This reads as "declare a vector called high_temps that will have 10 elements with each element being the value 85.0." The main difference here is we used () instead of {}.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    std::vector<int> test_scores(5, 95);
    for (int i : test_scores)
        cout << "test score = " << i << endl;

    return 0;
}
```

## Accessing and Modifying Vector Elements

We can start using object methods on vectors by doing the following:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    std::vector<int> test_scores(5, 95);

    cout << "The first element in out vector is " << test_scores.at(0) << endl;

    return 0;
}
```

The anatomy of this vector method is `vector_name.at(element_index)`. This method is prefered because it provides

### Vector assignment

To define a common assignment on a vector we use:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    std::vector<int> test_scores = {90, 86, 99, 79, 88};

    cout << "The first element in our vector is " << test_scores.at(0) << endl;

    test_scores.at(0) = 100;

    cout
        << "After declaring a new assignment, the first element in our vector is now " << test_scores.at(0) << endl;
    return 0;
}
```

Or another example is:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores(3, 0);

    cout << "Currently we have " << test_scores.size() << " elements in our vector." << endl;

    cout << "Enter 3 test scores: " << endl;

    cin >> test_scores.at(0);
    cin >> test_scores.at(1);
    cin >> test_scores.at(2);

    cout << "Now we have " << test_scores.size() << " elements in our vector." << endl;

    cout << test_scores.at(0) << endl;
    cout << test_scores.at(1) << endl;
    cout << test_scores.at(2) << endl;

    return 0;
}
```

### Dynamic Vectors in action

If we want to grow a vector we can use the `push_back()` method. For example:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores = {90, 86, 99, 79, 88};

    cout << "Currently we have: " <<  test_scores.size() << "elements in our vector" << endl;

    cout << "Now we will add a new element to our vector using the push_back() method." <<endl;

    test_scores.push_back(100);

    cout << "Now we have: " <<  test_scores.size() << "elements in our vector" << endl;

    return 0;
}
```

Or we can ask the user for the `score_to_add` and make this more dynamic.

```c++

#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores = {90, 86, 99, 79, 88};

    cout << "Currently we have: " << test_scores.size() << " elements in our vector" << endl;
    cout << test_scores.at(0) << endl;
    cout << test_scores.at(1) << endl;
    cout << test_scores.at(2) << endl;
    cout << test_scores.at(3) << endl;
    cout << test_scores.at(4) << endl;

    cout << "Enter a new test score to add to our vector: " << endl;

    int score_to_add = 0;
    cin >> score_to_add;

    test_scores.push_back(score_to_add);

    cout << "Now we have: " << test_scores.size() << " elements in our vector" << endl;

    cout << test_scores.at(0) << endl;
    cout << test_scores.at(1) << endl;
    cout << test_scores.at(2) << endl;
    cout << test_scores.at(3) << endl;
    cout << test_scores.at(4) << endl;
    cout << test_scores.at(5) << endl;

    return 0;
}
```

Lastly, to initialize a 2D-Vector we use the syntax:

```c++

vector <vector<int>> movie_ratings = 
{
    {1,2,3},
    {4,5,6},
    {7,8,9}
}
```

Example using a 2D-Vector:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> vector1 = {};
    vector<int> vector2 = {};

    vector1.push_back(10);
    vector1.push_back(20);

    cout << "The elements in vector1 are: " << endl;
    cout << vector1.at(0) << endl;
    cout << vector1.at(1) << endl;

    vector2.push_back(100);
    vector2.push_back(200);

    cout << "The elements in vector2 are: " << endl;
    cout << vector2.at(0) << endl;
    cout << vector2.at(1) << endl;

    vector<vector<int>> vector2d = {};

    vector2d.push_back(vector1);
    vector2d.push_back(vector2);

    cout << "The elements in vector2d are: " << endl;
    cout << vector2d.at(0).at(0) << " " << vector2d.at(0).at(1) << endl;
    cout << vector2d.at(1).at(0) << " " << vector2d.at(1).at(1) << endl;

    vector1.at(0) = 1000;

    cout << "The elements in vector2d are: " << endl;
    cout << vector2d.at(0).at(0) << " " << vector2d.at(0).at(1) << endl;
    cout << vector2d.at(1).at(0) << " " << vector2d.at(1).at(1) << endl;

    cout << "The elements in vector1 are: " << endl;
    cout << vector1.at(0) << endl;
    cout << vector1.at(1) << endl;

    return 0;
}
```

# Statements and Operators

## The assignment operator

`=` is understood by reading it as "refer to this value as this variable; which is now stored at a specific memory location."

Assignment is when you change the value of an already initialized variable.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    // This is called INITIALIZING
    int num_1 = {100};
    int num_2 = {500};

    // This is called ASSIGNMENT
    num_1 = 1200;

    cout << "Number 1 = " << num_1 << endl;
    cout << "Number 2 = " << num_2 << endl;

    return 0;
}
```

## Arithmetic operators

The same ones we use in math. For example, if we want to create a program that converts Euros to USD, we can follow this logic:

```c++
#include <iostream>
#include <vector>
using namespace std;

// Converting USD to EURO

int main()
{

    const double usd_to_euro = {1.19};

    cout << "How many Euro's do you have? " << endl;

    double euros = {0};
    cin >> euros;

    double conversion = {0};
    conversion = usd_to_euro * euros;

    cout << "This is equal to " << conversion << " USD" << endl;

    return 0;
}
```

## Increment and Decrement Operators

* `++` increment operand by 1
* `--` decrements operand by 1

For both of these increment and decrement operators we have pre and post increments.

The behavior is different so let's take a closer look.

For `pre-increment (++counter)`:

The value of our variable is fist incremented by 1 and then used inside the expression.

For `post-increment (counter++)`:

The value of our variable is first used in our expression and then incremented.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int counter = {0};

    cout << "The counter is currently: " << counter << endl;

    counter++; // adding 1 to the counter

    cout << "The counter is now: " << counter << endl; // this should show 1

    int result;

    result = ++counter; // this should be 2 bc of PRE-INCREMENT

    cout << "The result is: " << result << endl;
    return 0;
}
```

Using post-increment we get:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int counter = {0};

    cout << "The counter is currently: " << counter << endl;

    ++counter;

    cout << "The counter is now: " << counter << endl; // this should show 1

    int result;

    result = counter++; // this should be 1 because of POST-INCREMENT RULE
    // Here we are using the "old" value of counter AND THEN increasing by 1

    cout << "The result is: " << result << endl;

    cout << "The counter is: " << counter << endl;
    return 0;
}
```

To summarize both rules take a look at this code:

```c++

#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int counter = 10;

    cout << "The value of counter is: " << counter << endl;

    int result = 0;

    // using pre-increment

    result = ++counter;

    cout << "Using pre-increment result is " << result << " and counter is " << counter << endl;

    // using post-increment

    result = 0; // resetting result back to 0

    result = counter++; // here we are using the "old" counter value AND THEN  incrementing
    // next time you use counter it will be old value + 1

    cout << "Using post-increment result is " << result << " and counter is " << counter << endl;

    return 0;
}
```

## Mixed Type Expressions

Mixed type expressions is important to consider since C++ will apply operations on same type operands.

So, if you add an INT and another INT together the result will be an INT. BUT, what if you add an INT and a DOUBLE?

C++ will first attempt to convert the types but if it can't you will get a compiler error.

We can explicitly cast data types like the following:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int total_amount = 100;
    int total_units = 8;

    double average = 0;
    average = total_amount / total_units;

    cout << "The average is: " << average << endl;
    // here, average is 12 because we divided 2 integers.
    // what we want is 12.5, so we have to explicitly say "make one number a double"

    average = static_cast<double>(total_amount) / total_units;
    cout << "The average is: " << average << endl;

    return 0;
}
```

Here we are explicitly casting our `total_amount` to a double `100.0` so that when we divide, we get back a double.

Now, let's write out a program that will ask the user for 3 integers and we display both the sum and average.

```c++

#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int number_1 = 0;
    int number_2 = 0;
    int number_3 = 0;

    cout << "Enter 3 integers separated by a space: " << endl;

    cin >> number_1 >> number_2 >> number_3;

    int sum = 0;

    // sum can be an integer because we are adding 3 integers so we will never have a decimal
    sum = number_1 + number_2 + number_3;

    cout << "The sum of the 3 integers entered is: " << sum << endl;

    int count_of_numbers_entered = 3; // we need this to calculate the average

    double average = 0; // average HAS to be a double because averages can have decimals

    average = static_cast<double>(sum) / count_of_numbers_entered;

    cout << "The average of the three integers entered is: " << average << endl;

    return 0;
}
```

## Testing for Equality

Equality operators returns a Boolean (True or False).

* equals `==`
* not equal to `!=`

Note: reminder that type `double`'s are approximated so 12.0 == 11.999 will return true.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    bool result = false;

    result = (100 == 50 + 50);

    cout << result << endl; // by default a bool returns either 0 or 1

    cout << std::boolalpha; // this converts the bool value of 0 or 1 to false / true respectively

    cout << result << endl; // now, we will get back the word "true" and not "1"

    cout << std::noboolalpha; // this goes back to default behavior or printing 0 or 1

    return 0;
}
```

## Relational Operators

These are the greater than, less than, greater or equal to, less than or equal to.

The simplest example to see how relational operators work is to compare two numbers and show if the relational operators hold true.

```c++

#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int num_1 = 0;
    int num_2 = 0;

    cout << std::boolalpha; // used to print a nicer true/false

    cout << "Enter two numbers to compare: " << endl;

    cin >> num_1 >> num_2;

    cout << "Relationship summary: " << endl;

    // is num_1 greater than num_2

    cout << num_1 << " > " << num_2 << " : " << (num_1 > num_2) << endl;
    // is num_1 less than num_2
    cout << num_1 << " < " << num_2 << " : " << (num_1 < num_2) << endl;
    // is num_1 greater than or equal to num_2
    cout << num_1 << " >= " << num_2 << " : " << (num_1 >= num_2) << endl;
    // is num_1 less than or equal to num_2
    cout << num_1 << " <= " << num_2 << " : " << (num_1 <= num_2) << endl;
    return 0;
}

```

## Logical Operators

The standard logical operators are:

* `not !`
* `and &&`
* `or ||`

Logical operators work on boolean values and return back another boolean value. During run-time, logical operators follow the short-circuit evaluation.

The following example checks to see if a number is within a certain range.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    const int lower_range = 10;
    const int upper_range = 20;

    cout << std::boolalpha; // used to print a nicer true/false

    // ask the user to enter a number that's between our lower and upper range

    cout << "Enter a number that's greater than " << lower_range << " and less than " << upper_range << endl;

    // store the number in a variable
    int submitted_number = 0;

    cin >> submitted_number;

    // Check if the number is between the lower and upper range using logical operators.

    bool within_bounds = false;
    within_bounds = (submitted_number > lower_range && submitted_number < upper_range);

    cout << "Is your number within range? " << within_bounds << endl;

    return 0;
}

```

To check if a number is outside the range, we have to use the logical OR because it can be less than 10 OR greater than 20 in order for it to be considered "outside" the range.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    const int lower_range = 10;
    const int upper_range = 20;

    cout << std::boolalpha; // used to print a nicer true/false

    // ask the user to enter a number that's between our lower and upper range

    cout << "Enter a number that's less than " << lower_range << " or greater than " << upper_range << endl;

    // store the number in a variable
    int submitted_number = 0;

    cin >> submitted_number;

    // Check if the number is outside the lower and upper range using logical operators.

    bool outside_bounds = false;
    outside_bounds = (submitted_number < lower_range || submitted_number > upper_range);
    // here, the submitted_number has to be less than 10 OR greater than 20

    cout << "Is your number outside the range? " << outside_bounds << endl;

    return 0;
}

```

To put all of these logical operators to use, let's create a program that determines if we need to wear a coat.

The conditions that need to be true in order for you to wear a coat are:

1. temperature has to be less than or equal to 60 or wind is greater than 10 mph.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int wind_speed = 0;
    int temperature = 0;
    bool wear_coat = false;
    cout << std::boolalpha;

    cout << "Enter the current temperature: " << endl;
    cin >> temperature;

    cout << "Enter the current wind speed in mph: " << endl;
    cin >> wind_speed;

    wear_coat = (temperature <= 60 || wind_speed > 10);

    cout << "Should you wear a coat today? " << wear_coat << endl;

    return 0;
}

```

A more advanced problem that uses logical operators can be one that checks if a person can work based on these conditions:

* they must be 18 years or older OR be above the age of 15 and have parent's consent.
* additionally, they must have a ssn and no accidents.

To start this problem let's identify what HAS to be true for everyone who want to work.

1. They must have a Social Security Number
2. They must have NO accidents.

For age, they can be over 18 OR above 15 AND have parent's consent.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int age = 0;
    bool ssn = true;
    bool parent_consent = true;
    bool accidents = true;

    // what needs to be true for everyone?
    //  they must have a ssn and no accidents

    // for age, you can be 18 years old or older OR you can be older than 15 with parent consent.

    bool you_can_work = (ssn && !accidents && (age >= 18 || (age >= 16 && parent_consent)));

    return 0;
}
```

Section Challenge:

"How to provide change"

Given the amount of change in cents, return back the correct change breakdown.

For example:

* user enters 52 cents; program will say this is 2 quarters and 2 pennies.

* user enters 214 cents; program will say this is 2 dollars, 1 dime and 4 pennies.

```c++

#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int dollars = 100;
    int quarters = 25;
    int dimes = 10;
    int nickle = 5;
    int pennies = 1;

    // take in change amount from user
    cout << "Enter an amount in change: ";
    int change_amount = 0;
    cin >> change_amount;

    // number of dollars to give back
    int dollars_back = 0;
    dollars_back = change_amount / dollars;

    // find the remainder to continue program if 1 dollar is not enough
    int remainder = 0;
    remainder = change_amount % dollars;

    cout << "Dollars: " << dollars_back << endl;
    // cout << "Remainder: " << remainder << endl;

    // quarters to give back
    int quarters_back = 0;
    quarters_back = remainder / 25;

    // find the "new remainder" to continue program if quarters is not enough
    remainder = remainder % 25;

    cout << "Quarters: " << quarters_back << endl;
    // cout << "Remainder: " << remainder << endl;

    // dimes to give back
    int dimes_back = 0;
    dimes_back = remainder / 10;
    remainder = remainder % 10;
    cout << "Dimes: " << dimes_back << endl;
    // cout << "Remainder: " << remainder << endl;

    // nickles to give back
    int nickles_back = 0;
    nickles_back = remainder / 5;
    remainder = remainder % 5;
    cout << "Nickles: " << nickles_back << endl;
    // cout << "Remainder: " << remainder << endl;

    // pennies to give back

    int pennies_back = 0;
    pennies_back = remainder / 1;
    remainder = remainder % 1;

    cout << "Pennies: " << pennies_back << endl;
    // adding this to check the final remainder is 0 
    cout << "Remainder: " << remainder << endl;

    return 0;
}

```

# Controlling Program Flow

## if statement

A simple approach to adding decision making logic to our code. The general anatomy of the `if` statement is:

```c++
if (expression){
    dothis;
    andthis;
    andthis;
}
```

Here, we introduce a new block statement which means the variables and variable declarations are only visible within the block - which is called the local scope.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int num = 0;
    const int min = 10;
    const int max = 100;

    cout << "Enter a number between " << min << " and " << max << ": ";
    cin >> num;

    if (num >= min)
    {
        cout << num << " is greater than or equal to " << min << endl;
        int difference = 0;
        difference = num - min;
        cout << "The difference between " << num << " and " << min << " is " << difference << endl;
    }

    // cout << difference << endl;
    // The code above gives us an error because difference is inside the block of the if statement so it is
    // not available in this "outside" scope.

    if (num <= max)
    {
        cout << num << " is less than or equal to " << max << endl;
        int difference = 0;
        difference = max - num;
        cout << "The difference between " << max << " and " << num << " is " << difference << endl;
    }

    if (num >= min && num <= max)
    {
        cout << "Your number " << num << " is between " << min << " and " << max << endl;
    }

    if (num == min || num == max)
    {
        cout << "Your number " << num << " is on the boundary." << endl;
    }
}

```

## if else statement

The `else` statement allows us to create a statement to execute when the `if` statement is `false`. The basic anatomy of the `if else` statement is:

```c++
if (expression){
    dothis;
}
else {
    dothisinstead;
}
```

We also have the `if-else-if` statement which we can think of as multiple if statements and one else statement. The basic anatomy of this statement is:

```c++
if (expression){
    dothis;
} else if (expresion){
    dothis;
} else if (expression){
    dothis;
} else{
    dothis;
}

```

Here, we must rememeber that first the first `if` statement is checked. If it is `true` then the code inside the block executes. If the first `if` is false, we move on to the next `else if` statement. We continue this "check the next one" until we get back a true bool condition value.

A very simple example of this in action is:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int num = 0;

    cout << "Enter a number: ";

    cin >> num;
    // if this is true this block will execute
    if (num >= 80 && num < 90)
    {
        cout << "You have a B" << endl;
    }
    // the above if is false if this executes
    else if (num >= 90)
    {
        cout << "You have an A" << endl;
    }
    // this will only run IF all other else if statements are false
    else
    {
        cout << "I don't know what grade you have...." << endl;
    }
}

```

## Nested if statements

A nested if can allow us to perform logic checks inside out top most `if` statement. Here is a simple example, we take in a grade and determine if it is and A or A+.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int grade = 0;

    cout << "Enter your grade: " << endl;
    cin >> grade;

    // first we check if the grade is in the A range 
    if (grade >= 90)
    {
        // if the grade is equal to or above a 95 they got an A+
        if (grade >= 95)
        {
            cout << "A+" << endl;
        }
        // otherwise they get an A
        else
        {
            cout << "A" << endl;
        }
    }
    else
    // if the grade is not in the A range
    {
        cout << "Your grade is bellow a A" << endl;
    }
}

```

More practice: Ask the user for Frank's score and Baker's score. If the scores are equal the game is a tie, if they are not equal, tell me who won the game.

Here is a simple grade checker program that uses `if-else` and nested `if` statements.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int grade = 0;
    const int min = 0;
    const int max = 100;
    char letter_grade = {};

    cout << "Enter your grade: " << endl;
    cin >> grade;

    // first we check to see if the grade entered is inside the range of possible grades (between 0 and 100)
    if (grade >= min && grade <= max)
    {
        if (grade < 60)
        {
            letter_grade = 'F';
        }
        else if (grade >= 60 && grade < 70)
        {
            letter_grade = 'D';
        }
        else if (grade >= 70 && grade < 80)
        {
            letter_grade = 'C';
        }
        else if (grade >= 80 && grade < 90)
        {
            letter_grade = 'B';
        }
        else
        {
            letter_grade = 'A';
        }

        if (letter_grade == 'F')
        {
            cout << "Sorry your grade is an " << letter_grade << ", you will have to repeat the class." << endl;
        }
        else
        {
            cout << "Your letter grade is an: " << letter_grade << endl;
        }
    }
    else
    {
        cout << grade << " is not between " << min << " and " << max << endl;
    }
}

```

Next, we will make a shipping calculator program that will follow these rules:

* User will enter dimensions
* length, width and height should be integers
* ALL dimensions must be 10 inches or less otherwise we cannot ship
* Base cost = $2.50
  * if volume > 100 cubic feet there is a 10% surcharge
  * if volume > 500 there is a 25% surcharge

```c++
#include <iostream>
#include <vector>
#include <iomanip>
using namespace std;

int main()
{
    int length = 0;
    int width = 0;
    int height = 0;
    const int max_dimension = 10;

    int volume = 0;
    const double base_cost = 2.50;
    double final_rate = 0;
    double surcharge = 0;

    cout << "Enter the length, width and height of your package: ";
    cin >> length >> width >> height;

    volume = length * width * height;

    if (length <= max_dimension && width <= max_dimension && height <= max_dimension)
    {
        if (volume > 100 && volume < 500)
        {
            surcharge = base_cost * .10;
            final_rate = base_cost + surcharge;
        }
        else if (volume > 500)
        {
            surcharge = base_cost * .25;
            final_rate = base_cost + surcharge;
        }
        else
        {
            final_rate = 2.50;
        }
        cout << fixed << setprecision(2);
        cout << "Your final shipping rate is $" << final_rate << endl;
    }
    else
    {
        cout << "Sorry, one of your dimensions is greater than 10 inches, we cannot ship." << endl;
    }
}
```

## The switch-case Statement

By definition, a switch-case statement allows a variable to be tested for equality against a list of values.
Each value is called a case and the `switch (expression)` must be of `int` or `enum` type.

For this example, we will ask the user what grade they expect on an exam and we will provide the score they need to achieve this grade.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    char letter_grade = {};
    cout << "Enter the letter grade you expect on the exam: " << endl;
    cin >> letter_grade;

    switch (letter_grade)
    {
    case 'a':
    case 'A':
        cout << "You need a 90 or above for an A!" << endl;
        break;

    case 'b':
    case 'B':
        cout << "You need an 80- 89 for a B " << endl;
        break;

    case 'c':
    case 'C':
        cout << "You need a 70-79 for a C" << endl;
        break;

    case 'f':
    case 'F':
    {
        char confirm = {};
        cout << "Are you sure you want an F? confirm with (Y/N) " << endl;
        cin >> confirm;

        if (confirm == 'y' || confirm == 'Y')
        {
            cout << "Okay...I guess you didn't study." << endl;
        }
        else if (confirm == 'n' || confirm == 'N')
        {
            cout << "Good, go study!" << endl;
        }
        else
        {
            cout << "Sorry, invalid response." << endl;
        }
        break;
    }

    default:
        cout << "Sorry, not a valid grade" << endl;
    }

    return 0;
}
```

## Conditional Operator

The conditional operator is made up of `?:`. The basic syntax is `(condition) ? expression_1 : expression_2`.

Here, `condition` will evaluate to a boolean value. If true, the value of expression_1 is returned else, the value of expression_2 will be returned. This type of operator is similar to python inline list constructions but can be easy to abuse.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int a = 10;
    int b = 35;
    int score = 90;
    int result = 0;

    // condition returns false
    result = (a > b) ? 100 : 0;
    cout << result << endl;

    // condition returns true
    result = (b > a) ? (b + 15) : 0;
    cout << result << endl;

    cout << ((score == 90) ? "Excellent" : "Score is not equal to 90.");
}
```

Here we have a simple conditional operator program that checks if an input number is even or odd:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int num = 0;

    cout << "Enter a number: " << endl;
    cin >> num;

    cout << num << " is " << ((num % 2 == 0) ? "even" : "odd") << endl;
}
```

Another simple conditional operator program that summarizes which number is largest vs smallest between two inputs:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int num1 = 0;
    int num2 = 0;

    cout << "Enter two numbers separated by a space: " << endl;
    cin >> num1 >> num2;

    if (num1 != num2)
    {
        cout << "Largest: " << ((num1 > num2) ? num1 : num2) << endl;
        cout << "Smallest: " << ((num1 < num2) ? num1 : num2) << endl;
    }
    else
        (
            cout << "The numbers are equal" << endl;
}
```

## for loop

The basic syntax of the `for` loop is:

```c++
for (initialization; condition; increment){
    statement(s)
}
```

The `for` loop will run as long as the `condition` part is `true`, otherwise the loop terminates. So, first the initialization happens, next the condition is checked. If true, the body of the for loop runs otherwise the loop terminates. For the next iteration the increment occurs.

A simple example is a for loop that prints from 1-5:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    // initializing i to be of type int with value 0
    int i = 0;

    for (i = 1; i <= 5; ++i)
    {
        cout << i << endl;
    }
    return 0;
}

```

We can also initialize inside the for loop but must be careful because that initialization variable will only be visible INSIDE the for loop.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    // no int i = 0; initialization here 

    for (int i = 1; i <= 5; ++i)
    {
        cout << i << endl;
    }
    return 0;
}

```

Print out all even numbers from 1-20:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    for (int i = 1; i <= 20; ++i)
    {
        if (i % 2 == 0)
        {
            cout << i << endl;
        }
    }
    return 0;
}

```

It's common to see for loops used with arrays, for example we can print out certain or all elements in an array using a for loop.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int test_scores[5] = {90, 89, 99, 87, 79};
    // since out array has 5 elements but the first index is 0, asking for i < 5 will ensure all print
    for (int i = 0; i < 5; ++i)
    {
        cout << test_scores[i] << endl;
    }
    return 0;
}

```

In for loops, it is also common to see the `comma operator` being used to initialize and increment variables.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    for (int i = 1, j = 5; i <= 5; ++i, ++j)
    {
        cout << i << " * " << j << " = " << (i * j) << endl;
    }
    return 0;
}

```

We can count from 10 to 100 by increments of 10:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int i = 0;

    for (i = 10; i <= 100; i += 10)
    {
        cout << i << endl;
    }
    return 0;
}

```

Now we will make a program that tells me if a number is even or odd counting down from 10 to 1.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int i = 0;
    for (i = 10; i > 0; i -= 1)
    {
        if (i % 2 == 0)
        {
            cout << i << " is even." << endl;
        }
        else
            cout << i << " is odd. " << endl;
    }
    return 0;
}

```

For vector for loops, we have to use `unsigned` variables to avoid getting compiler error messages.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores = {78, 99, 85, 90, 60};
    for (unsigned i = 0; i < test_scores.size(); ++i)
        cout << test_scores[i] << endl;
    return 0;
}

```

Lastly, we have an example that counts up from 1 to 5 and takes the sum of all odd numbers.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int sum = 0;

    for (int i = 1; i <= 5; ++i)
    {
        sum += i;
    }
    cout << sum << endl;
    return 0;
}

```

## range-based for loop

Similar to a python for loop. There is no need to use `.size()`, we simply give the variable type, variable name and sequence. (var_type var_name : sequence)

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores = {78, 99, 85, 90, 60};

    // this reads as "for every score in our array called test_scores"
    for (int score : test_scores)
        cout << score << endl;
    return 0;
}
```

We can also skip the explicitly defining variables by using the `auto` keyword. The compiler will deduce the variable itself based on other parameters already known.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores = {78, 99, 85, 90, 60};

    // this reads as "for every score in our array called test_scores"
    // notice how we used auto instead of int 
    for (auto score : test_scores)
        cout << score << endl;
    return 0;
}

```

We can also find the sum of all elements in a vector and then the average using

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores = {78, 99, 85, 90, 60};
    int test_scores_sum = 0;

    // this reads as "for every score in our array called test_scores"
    for (auto score : test_scores)
        test_scores_sum += score;

    cout << "The total sum of all elements in our test scores array is: " << test_scores_sum << endl;

    // now that we know the sum of all elements, we can find the average of our test_scores array
    double average_score = 0;
    average_score = test_scores_sum / test_scores.size();

    cout << "The average test score is: " << average_score << endl;
    return 0;
}

```

## while loop

The `while` loop is different because the expression is evaluated at the beginning of the loop so, you can sometimes get no output. It's important to notice this behavior since sometimes you might think your code isn't running or another error exist when in reality, your while loop expression is simply not true.

```c++

while (expression){
    statements;
}
```

A `while loop` that counts up to 5 is shown here

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int i = 1;
    while (i <= 5)
    {
        cout << i << endl;
        ++i;
    }
}

```

compare this to a `for loop` that counts from 1 to 5

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    for (int i = 1; i <= 5; ++i)
    {
        cout << i << endl;
    }
}

```

Now, let's use a while loop that shows even numbers from 1 - 20

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int i = 1;
    while (i <= 20)
    {
        if (i % 2 == 0)
        {
            cout << i << " is even" << endl;
        }
        ++i;
    }
}
```

It is common to see `boolean flags` used with while loops. This is simply a variable that starts with one boolean value and WE set it to another value after "something" happens.

For example, here we are asking for a number greater than 1 but less than 10, then we get a number that is not between this range, we simply ask again and again until we have the number we want.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int num = 0;
    bool done = false;
    // "while not false" ; "not false" means "true"
    while (!done)
    {
        cout << "Enter a number greater than 1 and less than 10: " << endl;
        cin >> num;

        if (num > 1 & num < 10)
        {
            cout << "Thanks! " << endl;
            done = true;
        }
        else
        {
            cout << "Out of range...try again! " << endl;
            // since we didn't set out done flag to true, the while loop continues
        }
    }
}

```

A while loop that iterates through a vector and counts up until a certain number is found:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    // vector<int> test = {10, 20, 30, 40, 50, 110, 100};

    // int index = 0;
    // int count = 0;
    // bool flag = false;
    // while (index < test.size() && !flag)
    // {
    //     if (test[index] == 99)
    //     {
    //         int count = -1;
    //         flag = true;
    //         count += 1;
    //     }
    //     else
    //     {
    //         count += 1;
    //         ++index;
    //     }
    // }
    // cout << count << endl;
    vector<int> vec = {10, 20, 30, 40, 50, 99, 100};
    int count{0};
    size_t index{0}; // See the Q/A forum for more about size_t
                     // size_t is an unsigned int
                     // you can replace size_t with int or unsigned int and it will work fine

    while (index < vec.size() && vec.at(index) != 99)
    {
        ++count;
        ++index;
    }
    cout << count << endl;

    return 0;
}
```

## do while loop

Basic structure follows:

```c++
do {
    statements;
} while (expression);

```

The `while` part of the loop is checked after the `statement` part is ran which means you will alway get one statement run.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    // "if it's false, it will ask again"

    int number = 0;
    do
    {

        cout << "Enter a number between 1 and 5 (including bounds) " << endl;
        cin >> number;
        // while condition is what will cause this to stop
    } while (number < 1 || number > 5);

    cout << "Thank you for submitting your number! " << endl;

    return 0;
}

```

For this next example, we will ask for height and width and provide area. This will run as long as the user wants.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    char user_selection = {};

    do
    {
        double length = 0;
        double width = 0;

        cout << "Enter length and width separated by a space: " << endl;
        cin >> length >> width;

        double area = 0;
        area = length * width;

        cout << "The area is " << area << endl;
        // here we ask if they want to do another calculation
        cout << "Want to calculate another area? " << endl;
        cin >> user_selection;
    } while (user_selection == 'Y' || user_selection == 'y');

    cout << "Thank you for using the area calculator! " << endl;
    return 0;
}

```

## do-while vs while loop

Choosing between these two loops is not always clear. But for simplicity, choose `do-while` if you need your loop to execute at least once before deciding to terminate.

Here we have a menu option using `do-while` syntax.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    char user_selection = {};

    do
    {
        cout << "\n-----------------------" << endl;
        cout << "1: Do this" << endl;
        cout << "2: Do that" << endl;
        cout << "3: Do something else" << endl;
        cout << "Q: Quit" << endl;
        cout << "\n Enter your selection: " << endl;
        cin >> user_selection;

        if (user_selection == '1')
        {
            cout << "Doing this...." << endl;
        }
        else if (user_selection == '2')
        {
            cout << "Doing that...." << endl;
        }
        else if (user_selection == '3')
        {
            cout << "Doing something else...." << endl;
        }
        else if (user_selection == 'q' || user_selection == 'Q')
        {
            cout << "Goodbye! " << endl;
        }
        else
        {
            cout << "Invalid selection..." << endl;
        }
    } while (user_selection != 'Q' && user_selection != 'q');

    return 0;
}

```

## continue and break statements

With `continue` control immediately goes directly to the beginning of the loop for the next iteration.

With `break` control goes to the statement following the loop construct.

Here we will count from 1 to 10 but skip 5:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    cout << "Let's count from 1 to 10: " << endl;
    for (int i = 1; i <= 10; ++i)
    {
        if (i == 5)
        {
            continue;
        }
        cout << i << endl;
    }

    cout << "We are done counting!!" << endl;
    return 0;
}

```

Here we will count from 1 to 10 but once `i` is equal to 8 we will `break` from the loop:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    cout << "Let's count from 1 to 10: " << endl;
    for (int i = 1; i <= 10; ++i)
    {
        if (i == 8)
        {
            break;
        }
        cout << i << endl;
    }

    cout << "Oops, there was an 8 in this loop! " << endl;
    return 0;
}

```

## Nested Loops

* Think of this as "outer loop" and "inner loop". Typically, we see nested loops with multidimensional data structures like 2D arrays and or 3D etc.

There's this notion that the "inner loop loops faster" than the outer loop. To demonstrate this, let's look at this example:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    // outer value goes from 1 to 2
    for (int outer_val = 1; outer_val <= 2; ++outer_val)
    {
        // inner value goes from 1 to 3

        for (int inner_val = 1; inner_val <= 3; ++inner_val)
        {
            cout << outer_val << " , " << inner_val << endl;
        }
    }
}

```

What's happening here?

First the outer loop is 1, then we check the inner loop condition. The inner loop starts at 1 but then will increment all the way to 3. Once inner_val condition is false, we go back and check the outer loop condition again which means the variable is incremented by 1 and we loop all over again.

Next, we will look at 2D vector iteration.

Here, we are saying "for each vector in our 2D vector, give me each element of each vector." Note how we use `auto` so the compiler can deduce the vector data type automatically.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<vector<int>> vector_2D = {
        {1, 2, 3},
        {10, 20, 30, 40, 50},
        {
            100,
            110,
            120,
        }};

    // "for every vector in out 2D vector"
    for (auto vec : vector_2D)
    {
        // for every value in our vector
        for (auto val : vec)
        {
            cout << val << endl;
        }
        // add a new line after each vector is printed out
        cout << endl;
    }
}
```

Lastly, let's make a program that will ask the user how many pets they have and then ask for the names of the pets using the "how many" variable.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    // first we take in how many pets the user has
    int number_of_pets = 0;
    cout << "How many pets do you have? " << endl;
    cin >> number_of_pets;

    // next, we create the data structure to hold the name of pet's we are going to receive.
    vector<string> name_of_pets = {};

    // ask for each pet name ; iterate "up to" the number of pets the user has
    // this also ensures we ask for the right amount of pet names
    for (int i = 1; i <= number_of_pets; ++i)
    {
        string name = "";
        cout << "Enter the name for pet number " << i << endl;
        cin >> name;
        // store the pet name into our vector
        name_of_pets.push_back(name);
    }

    // display the pet names that were just submitted
    cout << "----------------------PET SUMMARY-------------------------" << endl;
    cout << "You have " << number_of_pets << " pets! Here are their names: " << endl;
    for (auto name : name_of_pets)
    {
        cout << name << endl;
    }
}

```

The key here, is that `for loop` that will only ask the right amount of times for pet names given the answer the user provided for the question "how many pets do you have?" We make sure to initialize `i` to `1` and the condition is `i <= number_of_pets` because we want to ask "up to" the amount of pets the user has.

# Characters and Strings
