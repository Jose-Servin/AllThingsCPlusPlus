
# Writting our first Program

It is very common for your first coding problem to be "Hello World." This is basically the simplest program you write at first to get an introduction to the code syntax and become familiar with how to "run" programs. Below is a simple "hello world" for c++.

```c++
#include <iostream>

int main(){
    
    std::cout << "Hello World" <<std::endl;
    return 0;
}
 
```

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

int main() {

    /* Creating variable to store user input*/
    int favorite_number; 

    /* Prompt user to enter their favorite number */
    std::cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    std::cin >> favorite_number;

    /* Responde back to user */
    std::cout << "Nice! That's my favorite number too! " <<std::endl;

    return 0;
}
```

Code Breakdown:

* `# include <iostream>` is needed because we need to use the input/output library. This allows the compiler to understand what `cout` and `cin` mean.
* all c++ programs must have ONE `int main()` function.
* `std::endl` is used to move the cursor to a new line after execution.

## Note

When trying to run this program, I wasn't able at first to input my favorite number. This issue as well as "how do I run this?" are addressed in this [video](https://www.youtube.com/watch?v=KhGnYWplLVo&ab_channel=TechDecodeTutorials)

# Common Errors

## What are Compiler Errors?

1. Syntax Errors: Something is wrong with your code structure.
2. Semantic Errors: Something is wrong with your logic.

In Visual Studio Code, the section "Problems" will help catch these Syntax Errors since it is actively scanning your code and checking to see you are following the conventions/rules.

## What are Compiler Warning?

Same as above, Visual Studio Code has the section called "Problems" that shows you any errors/warnings in real time so that you can fix them BEFORE you run your program. However, the difference here is that the compiler can still compile your code so it's not an error but rather a warning.

Most common, you might see compiler waning about "uninitialized" variables. This just means, you forgot to define what that variable value is. For example, the code below is going to print `favorite_number` but I never define what `favorite_number` is so, we get a compiler warning.

## "Uninitialized Variable" Compiler Warning

```c++

#include <iostream>

int main() {

    int favorite_number; 

    std::cout << favorite_number << std::endl;

    return 0;
}
```

When we run this, the terminal shows favorite_number =`176267360` which is just some random number that was compiled.

## "set but not used" Compiler Warning

You can also define a variable, give it a value but then forget to use it. This is also another common type of compiler warning and it will show up as "<variable_name> set but not used."

```c++
#include <iostream>

int main() {

    int favorite_number; 
    favorite_number = 1000;

    std::cout << "Hello World!" << std::endl;

    return 0;
}
```

The main idea and philosphy behind compiler warnings is that you should have none after you compile your code.

## What are Linker Errors?

Typically, this error occurs when a libary or object file is missing.

Think of this scenario:

* You need file_1, file_2 and file_3 to run your program.

If file_3 references something that is in file_1 or file_2 but they are deleted then you will most likely get a Linker Error.

## What are RunTime Errors?

Errors that occur when the program is executing.

Common RunTime Errors:

* Divide by Zero
* File note Found
* Out of Memory

You typically handle these errors by using `Exception Handling` which is a way to "anticipate" an error and give your program instructions on how to handle an error that might occur.

## What are LogicErrors?

LogicErrors are errors/bugs in your code that cause your programm to run incorrectly. This type of error is caused by the Programmer's logic, how you are trying to solve the problem presented.

# Structure of a C++ Program

## Basic Components (Basic Components create syntax)

* C++ has defined "keywords" which are reserved for the program. This means they are not available for re-defining and/or overloading.

* The `>>` and `<<` are called chevron keys.
* `>>` is called the "string extraction" operator; it takes something from the console and stores it to a variable.
* `<<` is called the "string insertion" operator. We insert whatever is on the right hand side to whatever is on the left.
* `::` is called the scope resolution operator.

## Preprocessor Directives

Preprocessor directives perform preliminary operations on C++ files before they are passed to the compiler. Some use-case examples are inserting files, specifying compile-time error message, defining conditional compilation conditions based on OS etc.

## The Main Function

The `main()` function must always return an integer. A zero 0 is returned when the program runs sucessfully.

The `main()` function represents the starting point of our program execution.

## Namespace

Namespace: the variables defined in C++; "standard variables" means they already have a specific meaning. For example, `cout` means "c out".

`std` is the name for the standard C++ namespace.

So, we know we can use `std::cout <<"Hello World" << std::endl;` to print out "Hello world" in the terminal. But what if we wanted to define our own `cout` function?

`baker::cout`

Now, C++ will be confused because there are two `cout` functions being called. This is why we use `std::` because we are telling the compiler "use the standard namespace that C++ knows when you run the cout function."

`::` this is called the "scope resolution operator" because it's used to define what scope the compiler should use when reading variables/commands.

We can explicitly define what namespace we want the compiler use by defining it before our main() function. This is called using the "namespace directive." For example:

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using namespace std;

int main()
{

    /* Creating variable to store user input*/
    int favorite_number;

    /* Prompt user to enter their favorite number */
    cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    cin >> favorite_number;

    /* Responde back to user */
    cout << "Nice! That's my favorite number too! " << endl;
    cout << "No really! " << favorite_number << " is my favorite number! " << endl;

    return 0;
}
```

This lets us type less and makes the code a little bit easier to read.

However, using the namespace directive bring in EVERYTHING from the `std` (standard namespace) so, more often we will see individual namespaces declared. This means you only declare "what" from the standard namespace you want to the compiler to reference.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 standard scope resolutions
using std::endl;

int main()
{

    /* Creating variable to store user input*/
    int favorite_number;

    /* Prompt user to enter their favorite number */
    cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    cin >> favorite_number;

    /* Responde back to user */
    cout << "Nice! That's my favorite number too! " << endl;
    cout << "No really! " << favorite_number << " is my favorite number! " << endl;

    return 0;
}
```

## Comments

Comments need to add meaning; do not state the obvious. Before writting comments ask yourself "is this providing any value?" Once thing to note is that comments never make it to the compiler. Preprocessors strip out comments so compiler never sees them. Think about this, why?

Well, comments are for humans, so the compiler does not need this "for human" code in order to compile.

Type of comments:

1. Single Line comments: `// This is an inline comment.`

2. Multiline Comment: `/* */`

## Basic I/O

I/O stands for Input/Output.

* We output to the console using `cout <<`.
  * anything on the right of `cout <<`  is sent to the console.
  * ex. `count << "Hello World";`
  * We can "chain" `cout`; we saw this in the "enter your favorite number" example.
  * ex. `cout << "No really! " << favorite_number << " is my favorite number! " << endl;`
  * Why do we commonly see `endl`? because line breaks are not automatically added
* We input (take in) information from the user using `cin >>`.
  * The information that is inputted is saved to the variables on the right of `cin >>`.
  * This process can also be chained. `cin >> data1 >> data2` This means, whatever is typed in the keyboard is going to be stored in both data1 and data2.
  * We can get fails if the information being inputted is not the type we expected (defined).

A simple example of I/O (Input/Output) is asking for two numbers and storing them.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{

    int number1;
    int number2;

    cout << "Enter a number from 1 - 100: ";

    cin >> number1;

    cout << "Enter another number from 1 - 100: ";

    cin >> number2;

    cout << "You entered " << number1 << " and " << number2 << endl;

    return 0;
}
```

We can also see how c++ ignores whitespace by taking in both numbers at the same time.

So now, when we enter "12 23" 12 will be assigned to `number1` and 23 will be assigned to `number2`. All in one command! Keep in mind that the space between 12 and 23 is important because c++ compiler looks for it to see where your favorite number/input starts and ends.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{

    int number1;
    int number2;

    cout << "Enter two numbers from 1 - 100 seperated by a space: ";

    cin >> number1 >> number2;

    cout << "You entered " << number1 << " and " << number2 << endl;

    return 0;
}
```
