
# Writting our first Program

It is very common for your first coding problem to be "Hello World." This is basically the simplest program you write at first to get an introduction to the code syntax and become familiar with how to "run" programs. Below is a simple "hello world" for c++.

```c++
#include <iostream>

int main(){
    
    std::cout << "Hello World" <<std::endl;
    return 0;
}
 
```

The general C++ process is:

1. Code - write the program.
2. Save - save the program.
3. Compile - compile via terminal.
    * typically done using the `g++ <file_name>` command.
    * this produces a file called `a.out`.
    * Next, we run the `a.out` file which is now machine code using `./a.out`.
4. Execute - execute via terminal.

We can name the output executable file by using the command `g++ hello.cpp -o hello`.

Now, our executable file can run using `./hello`.

NOTE: For my Mac I use `g++ -std=c++11 <filename>`.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

int main() {

    /* Creating variable to store user input*/
    int favorite_number; 

    /* Prompt user to enter their favorite number */
    std::cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    std::cin >> favorite_number;

    /* Responde back to user */
    std::cout << "Nice! That's my favorite number too! " <<std::endl;

    return 0;
}
```

Code Breakdown:

* `# include <iostream>` is needed because we need to use the input/output library. This allows the compiler to understand what `cout` and `cin` mean.
* all c++ programs must have ONE `int main()` function.
* `std::endl` is used to move the cursor to a new line after execution.

## Note

When trying to run this program, I wasn't able at first to input my favorite number. This issue as well as "how do I run this?" are addressed in this [video](https://www.youtube.com/watch?v=KhGnYWplLVo&ab_channel=TechDecodeTutorials)

# Common Errors

## What are Compiler Errors?

1. Syntax Errors: Something is wrong with your code structure.
2. Semantic Errors: Something is wrong with your logic.

In Visual Studio Code, the section "Problems" will help catch these Syntax Errors since it is actively scanning your code and checking to see you are following the conventions/rules.

## What are Compiler Warning?

Same as above, Visual Studio Code has the section called "Problems" that shows you any errors/warnings in real time so that you can fix them BEFORE you run your program. However, the difference here is that the compiler can still compile your code so it's not an error but rather a warning.

Most common, you might see compiler waning about "uninitialized" variables. This just means, you forgot to define what that variable value is. For example, the code below is going to print `favorite_number` but I never define what `favorite_number` is so, we get a compiler warning.

## "Uninitialized Variable" Compiler Warning

```c++

#include <iostream>

int main() {

    int favorite_number; 

    std::cout << favorite_number << std::endl;

    return 0;
}
```

When we run this, the terminal shows favorite_number =`176267360` which is just some random number that was compiled.

## "set but not used" Compiler Warning

You can also define a variable, give it a value but then forget to use it. This is also another common type of compiler warning and it will show up as "<variable_name> set but not used."

```c++
#include <iostream>

int main() {

    int favorite_number; 
    favorite_number = 1000;

    std::cout << "Hello World!" << std::endl;

    return 0;
}
```

The main idea and philosphy behind compiler warnings is that you should have none after you compile your code.

## What are Linker Errors?

Typically, this error occurs when a libary or object file is missing.

Think of this scenario:

* You need file_1, file_2 and file_3 to run your program.

If file_3 references something that is in file_1 or file_2 but they are deleted then you will most likely get a Linker Error.

## What are RunTime Errors?

Errors that occur when the program is executing.

Common RunTime Errors:

* Divide by Zero
* File note Found
* Out of Memory

You typically handle these errors by using `Exception Handling` which is a way to "anticipate" an error and give your program instructions on how to handle an error that might occur.

## What are LogicErrors?

LogicErrors are errors/bugs in your code that cause your programm to run incorrectly. This type of error is caused by the Programmer's logic, how you are trying to solve the problem presented.

# Structure of a C++ Program

## Basic Components (Basic Components create syntax)

* C++ has defined "keywords" which are reserved for the program. This means they are not available for re-defining and/or overloading.

* The `>>` and `<<` are called chevron keys.
* `>>` is called the "string extraction" operator; it takes something from the console and stores it to a variable.
* `<<` is called the "string insertion" operator. We insert whatever is on the right hand side to whatever is on the left.
* `::` is called the scope resolution operator.

## Preprocessor Directives

Preprocessor directives perform preliminary operations on C++ files before they are passed to the compiler. Some use-case examples are inserting files, specifying compile-time error message, defining conditional compilation conditions based on OS etc.

## The Main Function

The `main()` function must always return an integer. A zero 0 is returned when the program runs sucessfully.

The `main()` function represents the starting point of our program execution.

## Namespace

Namespace: the variables defined in C++; "standard variables" means they already have a specific meaning. For example, `cout` means "c out".

`std` is the name for the standard C++ namespace.

So, we know we can use `std::cout <<"Hello World" << std::endl;` to print out "Hello world" in the terminal. But what if we wanted to define our own `cout` function?

`baker::cout`

Now, C++ will be confused because there are two `cout` functions being called. This is why we use `std::` because we are telling the compiler "use the standard namespace that C++ knows when you run the cout function."

`::` this is called the "scope resolution operator" because it's used to define what scope the compiler should use when reading variables/commands.

We can explicitly define what namespace we want the compiler use by defining it before our main() function. This is called using the "namespace directive." For example:

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using namespace std;

int main()
{

    /* Creating variable to store user input*/
    int favorite_number;

    /* Prompt user to enter their favorite number */
    cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    cin >> favorite_number;

    /* Responde back to user */
    cout << "Nice! That's my favorite number too! " << endl;
    cout << "No really! " << favorite_number << " is my favorite number! " << endl;

    return 0;
}
```

This lets us type less and makes the code a little bit easier to read.

However, using the namespace directive bring in EVERYTHING from the `std` (standard namespace) so, more often we will see individual namespaces declared. This means you only declare "what" from the standard namespace you want to the compiler to reference.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 standard scope resolutions
using std::endl;

int main()
{

    /* Creating variable to store user input*/
    int favorite_number;

    /* Prompt user to enter their favorite number */
    cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    cin >> favorite_number;

    /* Responde back to user */
    cout << "Nice! That's my favorite number too! " << endl;
    cout << "No really! " << favorite_number << " is my favorite number! " << endl;

    return 0;
}
```

## Comments

Comments need to add meaning; do not state the obvious. Before writting comments ask yourself "is this providing any value?" Once thing to note is that comments never make it to the compiler. Preprocessors strip out comments so compiler never sees them. Think about this, why?

Well, comments are for humans, so the compiler does not need this "for human" code in order to compile.

Type of comments:

1. Single Line comments: `// This is an inline comment.`

2. Multiline Comment: `/* */`

## Basic I/O

I/O stands for Input/Output.

* We output to the console using `cout <<`.
  * anything on the right of `cout <<`  is sent to the console.
  * ex. `count << "Hello World";`
  * We can "chain" `cout`; we saw this in the "enter your favorite number" example.
  * ex. `cout << "No really! " << favorite_number << " is my favorite number! " << endl;`
  * Why do we commonly see `endl`? because line breaks are not automatically added
* We input (take in) information from the user using `cin >>`.
  * The information that is inputted is saved to the variables on the right of `cin >>`.
  * This process can also be chained. `cin >> data1 >> data2` This means, whatever is typed in the keyboard is going to be stored in both data1 and data2.
  * We can get fails if the information being inputted is not the type we expected (defined).

A simple example of I/O (Input/Output) is asking for two numbers and storing them.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{

    int number1;
    int number2;

    cout << "Enter a number from 1 - 100: ";

    cin >> number1;

    cout << "Enter another number from 1 - 100: ";

    cin >> number2;

    cout << "You entered " << number1 << " and " << number2 << endl;

    return 0;
}
```

We can also see how c++ ignores whitespace by taking in both numbers at the same time.

So now, when we enter "12 23" 12 will be assigned to `number1` and 23 will be assigned to `number2`. All in one command! Keep in mind that the space between 12 and 23 is important because c++ compiler looks for it to see where your favorite number/input starts and ends.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{

    int number1;
    int number2;

    cout << "Enter two numbers from 1 - 100 seperated by a space: ";

    cin >> number1 >> number2;

    cout << "You entered " << number1 << " and " << number2 << endl;

    return 0;
}
```

# Variables and Constants

## What are variables?

* Variables are abstractions for a memory location.
* In Python, we've seen how a variable is simply a memory locations; the same applies in C++.
* All variables must have a type and value.
* IMPORTANT: variables must be declared before they are used. (This is called static typing)

<dl>
  <dt>Static Typing: </dt>
  <dd>A coding language where VARIABLE TYPES are known at compile time.</dd>
</dl>

```c++
#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{
    int number1;
    number1 = 23;
    return 0;
}
```

Compare the code above with this example:

```c++
#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{
    number1 = 23;
    return 0;
}
```

Here, we will get a compiler error becuase we didn't define the variable `type`. The compiler doesn't know if numer1 is suppose to be a character, integer, float etc. In other coding languages, this is not the case. In Python, we can simply declare `age = 23` but not in C++.

## How to declare and initialize a variable

Each variable is created using `VariableType VariableName;`.

What kind of variable types exist?

1. integer `int`
2. double `double` (decimal numbers)
3. string `string` (text)
4. Object Orriented Variables `OOP_Var` ex. `Person`, `Account`

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Enter the width of the room: ";
    int room_width;
    cin >> room_width;

    cout << "Enter the length of the room: ";
    int room_length;
    cin >> room_length;

    cout << "The area of the room is: " << room_width * room_length << " square feet" << endl;

    return 0;
}
```

## Primative Data Types

* The `char` (character) data type must use single quotes when declaring. `char middle_initial = 'J';`
* `unsigned int` are positive numbers and zero.
* `float` data type will hold decimal numbers.
* `double` is for large decimal numbers.
* `long double` is for numbers that use `e` powers.
* `bool` is for True/False values. `True = 1`; `False = 0`.

Note: In C++, if we aren't using C++11 compiler or newer, we will not see overflow errros and instead get inaccurate integer representations.

Overflow is when a variables being declared does not have enough storage to store the initialized variable. Be careful when doing calculations! Think about two `short * short` integers being multipled. The answer will not fit into a `short` so we have to declare it using a different data type.

## What is the size of a variable (sizeof)

The `sizeof` operator determines the size in bytes of a type or variable.

`sizeof` uses the `climits` and `cfloat` include files to provide size and precision about our varibles.

```c++
#include <iostream>
#include <climits>
```

## What is a Constant?

Constants are variables that cannot change once declared.

The most common way of declaring a constant is by using the `const` keyword followed by the name of the constant and the value. Constants must be initialized, meaning they must be given their value. For example, `const int months = 12;` shows the constant "months" having the value 12 since there will always be 12 months in a year.

Another "older" way of defining constants is by using `#define` but this is an old way and should no longer be used in Modern c++ compilers.

Here we have an example of a program that uses literal constants:

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Welcome to Baker's Cleaning Service" << endl;

    cout << "\nEnter the number of rooms you want cleaned: ";
    int number_of_rooms;
    cin >> number_of_rooms;

    cout << "\nEstimate of Cleaning Service: " << endl;
    cout << "Number of rooms: " << number_of_rooms << endl;
    cout << "Price per room $" << 30 << endl;
    cout << "Cost $" << 30 * number_of_rooms << endl;
    cout << "Tax $" << 30 * number_of_rooms * 0.06 << endl;
    cout << "==========================" << endl;
    cout << "Total Estimate: $" << (30 * number_of_rooms) + (30 * number_of_rooms * 0.06) << endl;
    cout << "This estimate is valid for " << 30 << " days" << endl;
    return 0;
}
```

Major disadvantages:

1. If you change your price per room you will have to go into the code and change every "30" to a new price.
2. It is harder to maintain and make changes.

Here is an example of the same program using declared constants. Doing this type of change, where you go into your code and make it better to read is called "refactoring." Rememeber, refactoring is simply making your code easier to read. It is not changing the logic etc.

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Welcome to Baker's Cleaning Service" << endl;

    cout << "\nEnter the number of rooms you want cleaned: ";
    int number_of_rooms;
    cin >> number_of_rooms;

    const double price_per_room = 30.0; // use double because maybe you want to charge $30.5 per room 
    const double tax_rate = 0.06;
    const int days_valid = 30; // use int because days will always be whole numbers

    cout << "\nEstimate of Cleaning Service: " << endl;
    cout << "Number of rooms: " << number_of_rooms << endl;
    cout << "Price per room $" << price_per_room << endl;
    cout << "Cost $" << price_per_room * number_of_rooms << endl;
    cout << "Tax $" << price_per_room * number_of_rooms * tax_rate << endl;
    cout << "==========================" << endl;
    cout << "Total Estimate: $" << (price_per_room * number_of_rooms) + (price_per_room * number_of_rooms * tax_rate) << endl;
    cout << "This estimate is valid for " << days_valid << " days" << endl;
    return 0;
}

```

Notice how our `cout` statements are much easier to read and we can follow along and "read" what each statement should be printing out to the console. Also, if we want to change `price_per_room`, `tax_rate` or `days_valid` the change will only have to be made in one place.

### Challenge: Enter the number of small and large rooms and return a total cleaning price

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Welcome to Baker's Cleaning Service" << endl;

    cout << "\nEnter the number of small rooms you want cleaned: ";
    int small_rooms;
    cin >> small_rooms;

    cout << "\nEnter the number of large rooms you want cleaned: ";
    int large_rooms;
    cin >> large_rooms;

    const double small_room_rate = 25.0;
    const double large_room_rate = 35.0;
    const double tax_rate = 0.06;
    const int days_valid = 30;

    cout << "\nEstimate of Cleaning Service: " << endl;
    cout << "Number of small rooms: " << small_rooms << endl;
    cout << "Number of large rooms: " << large_rooms << endl;
    cout << "Price per small room $" << small_room_rate << endl;
    cout << "Price per large room $" << large_room_rate << endl;
    cout << "Cost $" << (small_rooms * small_room_rate) + (large_rooms * large_room_rate) << endl;
    cout << "Tax $" << ((small_rooms * small_room_rate) + (large_rooms * large_room_rate)) * tax_rate << endl;
    cout << "==========================" << endl;
    cout << "Total Estimate: $" << (small_rooms * small_room_rate) + (large_rooms * large_room_rate) + (((small_rooms * small_room_rate) + (large_rooms * large_room_rate)) * tax_rate) << endl;
    cout << "This estimate is valid for " << days_valid << " days" << endl;
    return 0;
}
```

# Arrays and Vectors

The "compound data type" is a type made up of other data types.

## What is an array?

An array is a collection of elements. Where each element can be easily accessed directly.

* IMPORTANT: all elements must be of the same type.

Characteristics of an Array:

* They are fixed size.
* Arrays are contiguously in memory; this mean the memory for this array is allocated in one chunk.
* Elements are accessed via index or poistion. (index starts at 0, -1 index is the last element)

## How to decalre and initialize an Array

The basic anatomy of an array:

`Element_Type array_name [number of elements in the array] = {initializer list};`

For example:

`int test_scores [5] = {90,89,99,87,79};`

Here we are saying "compile an array of integers called test_scores that will hold 5 values and these are the values.

`int high_scores [10] = {35, 75};`

Here we define an array called high_scores that will hold 10 integers but only initialized 2 elements. This means, the remaining elements will be 0's.

`int another_aray [] = {9,3,2,4};`

Here we did not define the array size but because we initialized it the size is automatically calcualted.

## How to access and modify array elements

We start with an array called `test_scores`.

`int test_scores [5]  = {90,85,76,93,99};`

To get the first element of an array we can `cout << "First element: " << test_scores[0];`.

REMEMBER: indexes start at 0 not 1.
So FIRST element is at index 0, second element is at index 1, third element is at index 2....do you see the relationship?

If you want the 23rd ELEMENT you search index 22. (index is always "element you want - 1")

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    int test_scores[5] = {90, 85, 76, 93, 99};

    cout << "The FOURTH ELEMENT in the array is: " << test_scores[3] << endl;
    return 0;
}
```

We can modify an array element by using the same indexing method. For example, let's ask the user to update the SECOND ELEMENT (so index 1) of the test_scores array:

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    int test_scores[5] = {90, 85, 76, 93, 99};

    cout << "The current value of the second elemenent in the test_scores array is: " << test_scores[1] << endl;

    cout << "Enter the new value of the second array element: ";

    cin >> test_scores[1];

    cout << "The new value for test_scores[1] is now: " << test_scores[1] << endl;
    return 0;
}
```

We can also assign elements in our code (not having to ask the user) by using `array_name[index] = new_value`.

## Multidimensional Arrays

The basic syntax to define a multidimensional array is:

`Element_Type array_name [dimension_one][dimension_two];` we can also think of this as
`[number of rows][number of columns]`

We index multidimensional arrays using `[row][column]` indexes.

NOTE: index count starts at 0 for both rows and columns. So the first row is row index 0 and the first column is also index 0.

Therefore, if you want the first element in a multidimensional array you use:
`array_created[0][0]`.

```c++
#include <iostream>
using namespace std;

int main()
{

    int movie_ratings[3][4] = {
        {1, 2, 3, 4},
        {2, 2, 100, 4},
        {5, 6, 8, 2}};

    cout << "The element in the second row, third column is " << movie_ratings[1][2] << endl;

    return 0;
}
```

## Declaring and Initializing Vectors

A vector is simply a "dynamic" array; this just means it can change based on the conditions it runs under. During one run it can contain 5 "things", the next run you can have 100 "things".

Dynamic: something that can change depending on certain conditions. So a vector is just an array that can shrink and grow at execution time.

Pros:

* provides bounds checking so no spillage can occur.
* vectors have lots of useful function such as `sort`, `reverse` and `find`.
* VERY `efficient`.

To start using vectors, we must first declare them using `#include <vector>`. Next, we can declare our vector:
`vector <int> test_scores (5);`.

Here we are declaring a vector called test_scores that will have 5 elements of integer type in it. So, to actually create a vector we can do the following:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    std::vector<int> test_scores = {78, 99, 85, 90, 60};
    cout << "The first element in this vector is: " << test_scores[0] << endl;

    return 0;
}
```

To compile and run we use `g++ -std=c++11 run.cpp` and then `./a.out`.

We can also declare and initialize a vector using `vector <double> high_temps (10, 85.0);`. This reads as "declare a vector called high_temps that will have 10 elements with each element being the value 85.0." The main difference here is we used () instead of {}.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    std::vector<int> test_scores(5, 95);
    for (int i : test_scores)
        cout << "test score = " << i << endl;

    return 0;
}
```

## Accessing and Modifying Vector Elements

We can start using object methods on vectors by doing the following:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    std::vector<int> test_scores(5, 95);

    cout << "The first element in out vector is " << test_scores.at(0) << endl;

    return 0;
}
```

The anatomy of this vector method is `vector_name.at(element_index)`. This method is prefered because it provides

### Vector assignment

To define a common assignment on a vector we use:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    std::vector<int> test_scores = {90, 86, 99, 79, 88};

    cout << "The first element in our vector is " << test_scores.at(0) << endl;

    test_scores.at(0) = 100;

    cout
        << "After declaring a new assignment, the first element in our vector is now " << test_scores.at(0) << endl;
    return 0;
}
```

Or another example is:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores(3, 0);

    cout << "Currently we have " << test_scores.size() << " elements in our vector." << endl;

    cout << "Enter 3 test scores: " << endl;

    cin >> test_scores.at(0);
    cin >> test_scores.at(1);
    cin >> test_scores.at(2);

    cout << "Now we have " << test_scores.size() << " elements in our vector." << endl;

    cout << test_scores.at(0) << endl;
    cout << test_scores.at(1) << endl;
    cout << test_scores.at(2) << endl;

    return 0;
}
```

### Dynamic Vectors in action

If we want to grow a vector we can use the `push_back()` method. For example:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores = {90, 86, 99, 79, 88};

    cout << "Currently we have: " <<  test_scores.size() << "elements in our vector" << endl;

    cout << "Now we will add a new element to our vector using the push_back() method." <<endl;

    test_scores.push_back(100);

    cout << "Now we have: " <<  test_scores.size() << "elements in our vector" << endl;

    return 0;
}
```

Or we can ask the user for the `score_to_add` and make this more dynamic.

```c++

#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> test_scores = {90, 86, 99, 79, 88};

    cout << "Currently we have: " << test_scores.size() << " elements in our vector" << endl;
    cout << test_scores.at(0) << endl;
    cout << test_scores.at(1) << endl;
    cout << test_scores.at(2) << endl;
    cout << test_scores.at(3) << endl;
    cout << test_scores.at(4) << endl;

    cout << "Enter a new test score to add to our vector: " << endl;

    int score_to_add = 0;
    cin >> score_to_add;

    test_scores.push_back(score_to_add);

    cout << "Now we have: " << test_scores.size() << " elements in our vector" << endl;

    cout << test_scores.at(0) << endl;
    cout << test_scores.at(1) << endl;
    cout << test_scores.at(2) << endl;
    cout << test_scores.at(3) << endl;
    cout << test_scores.at(4) << endl;
    cout << test_scores.at(5) << endl;

    return 0;
}
```

Lastly, to initialize a 2D-Vector we use the syntax:

```c++

vector <vector<int>> movie_ratings = 
{
    {1,2,3},
    {4,5,6},
    {7,8,9}
}
```

Example using a 2D-Vector:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    vector<int> vector1 = {};
    vector<int> vector2 = {};

    vector1.push_back(10);
    vector1.push_back(20);

    cout << "The elements in vector1 are: " << endl;
    cout << vector1.at(0) << endl;
    cout << vector1.at(1) << endl;

    vector2.push_back(100);
    vector2.push_back(200);

    cout << "The elements in vector2 are: " << endl;
    cout << vector2.at(0) << endl;
    cout << vector2.at(1) << endl;

    vector<vector<int>> vector2d = {};

    vector2d.push_back(vector1);
    vector2d.push_back(vector2);

    cout << "The elements in vector2d are: " << endl;
    cout << vector2d.at(0).at(0) << " " << vector2d.at(0).at(1) << endl;
    cout << vector2d.at(1).at(0) << " " << vector2d.at(1).at(1) << endl;

    vector1.at(0) = 1000;

    cout << "The elements in vector2d are: " << endl;
    cout << vector2d.at(0).at(0) << " " << vector2d.at(0).at(1) << endl;
    cout << vector2d.at(1).at(0) << " " << vector2d.at(1).at(1) << endl;

    cout << "The elements in vector1 are: " << endl;
    cout << vector1.at(0) << endl;
    cout << vector1.at(1) << endl;

    return 0;
}
```

# Statements and Operators

## The assignment operator

`=` is understood by reading it as "refer to this value as this variable; which is now stored at a specific memory location."

Assignment is when you change the value of an already initialized variable.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    // This is called INITIALIZING
    int num_1 = {100};
    int num_2 = {500};

    // This is called ASSIGNMENT
    num_1 = 1200;

    cout << "Number 1 = " << num_1 << endl;
    cout << "Number 2 = " << num_2 << endl;

    return 0;
}
```

## Arithmetic operators

The same ones we use in math. For example, if we want to create a program that converts Euros to USD, we can follow this logic:

```c++
#include <iostream>
#include <vector>
using namespace std;

// Converting USD to EURO

int main()
{

    const double usd_to_euro = {1.19};

    cout << "How many Euro's do you have? " << endl;

    double euros = {0};
    cin >> euros;

    double conversion = {0};
    conversion = usd_to_euro * euros;

    cout << "This is equal to " << conversion << " USD" << endl;

    return 0;
}
```

## Increment and Decrement Operators

* `++` increment operand by 1
* `--` decrements operand by 1

For both of these increment and decrement operators we have pre and post increments.

The behavior is different so let's take a closer look.

For `pre-increment (++counter)`:

The value of our variable is fist incremented by 1 and then used inside the expression.

For `post-increment (counter++)`:

The value of our variable is first used in our expression and then incremented.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int counter = {0};

    cout << "The counter is currently: " << counter << endl;

    counter++; // adding 1 to the counter

    cout << "The counter is now: " << counter << endl; // this should show 1

    int result;

    result = ++counter; // this should be 2 bc of PRE-INCREMENT

    cout << "The result is: " << result << endl;
    return 0;
}
```

Using post-increment we get:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{

    int counter = {0};

    cout << "The counter is currently: " << counter << endl;

    ++counter;

    cout << "The counter is now: " << counter << endl; // this should show 1

    int result;

    result = counter++; // this should be 1 because of POST-INCREMENT RULE
    // Here we are using the "old" value of counter AND THEN increasing by 1

    cout << "The result is: " << result << endl;

    cout << "The counter is: " << counter << endl;
    return 0;
}
```

To summarize both rules take a look at this code:

```c++

#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int counter = 10;

    cout << "The value of counter is: " << counter << endl;

    int result = 0;

    // using pre-increment

    result = ++counter;

    cout << "Using pre-increment result is " << result << " and counter is " << counter << endl;

    // using post-increment

    result = 0; // resetting result back to 0

    result = counter++; // here we are using the "old" counter value AND THEN  incrementing
    // next time you use counter it will be old value + 1

    cout << "Using post-increment result is " << result << " and counter is " << counter << endl;

    return 0;
}
```

## Mixed Type Expressions

Mixed type expressions is important to consider since C++ will apply operations on same type operands.

So, if you add an INT and another INT together the result will be an INT. BUT, what if you add an INT and a DOUBLE?

C++ will first attempt to convert the types but if it can't you will get a compiler error.

We can explicitly cast data types like the following:

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int total_amount = 100;
    int total_units = 8;

    double average = 0;
    average = total_amount / total_units;

    cout << "The average is: " << average << endl;
    // here, average is 12 because we divided 2 integers.
    // what we want is 12.5, so we have to explicitly say "make one number a double"

    average = static_cast<double>(total_amount) / total_units;
    cout << "The average is: " << average << endl;

    return 0;
}
```

Here we are explicitly casting our `total_amount` to a double `100.0` so that when we divide, we get back a double.

Now, let's write out a program that will ask the user for 3 integers and we display both the sum and average.

```c++

#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int number_1 = 0;
    int number_2 = 0;
    int number_3 = 0;

    cout << "Enter 3 integers separated by a space: " << endl;

    cin >> number_1 >> number_2 >> number_3;

    int sum = 0;

    // sum can be an integer because we are adding 3 integers so we will never have a decimal
    sum = number_1 + number_2 + number_3;

    cout << "The sum of the 3 integers entered is: " << sum << endl;

    int count_of_numbers_entered = 3; // we need this to calculate the average

    double average = 0; // average HAS to be a double because averages can have decimals

    average = static_cast<double>(sum) / count_of_numbers_entered;

    cout << "The average of the three integers entered is: " << average << endl;

    return 0;
}
```

## Testing for Equality

Equality operators returns a Boolean (True or False).

* equals `==`
* not equal to `!=`

Note: reminder that type `double`'s are approximated so 12.0 == 11.999 will return true.

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    bool result = false;

    result = (100 == 50 + 50);

    cout << result << endl; // by default a bool returns either 0 or 1

    cout << std::boolalpha; // this converts the bool value of 0 or 1 to false / true respectively

    cout << result << endl; // now, we will get back the word "true" and not "1"

    cout << std::noboolalpha; // this goes back to default behavior or printing 0 or 1

    return 0;
}
```

## Relational Operators

These are the greater than, less than, greater or equal to, less than or equal to.
