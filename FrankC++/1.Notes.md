
# Writting our first Program

It is very common for your first coding problem to be "Hello World." This is basically the simplest program you write at first to get an introduction to the code syntax and become familiar with how to "run" programs. Below is a simple "hello world" for c++.

```c++
#include <iostream>

int main(){
    
    std::cout << "Hello World" <<std::endl;
    return 0;
}
 
```

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

int main() {

    /* Creating variable to store user input*/
    int favorite_number; 

    /* Prompt user to enter their favorite number */
    std::cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    std::cin >> favorite_number;

    /* Responde back to user */
    std::cout << "Nice! That's my favorite number too! " <<std::endl;

    return 0;
}
```

Code Breakdown:

* `# include <iostream>` is needed because we need to use the input/output library. This allows the compiler to understand what `cout` and `cin` mean.
* all c++ programs must have ONE `int main()` function.
* `std::endl` is used to move the cursor to a new line after execution.

## Note

When trying to run this program, I wasn't able at first to input my favorite number. This issue as well as "how do I run this?" are addressed in this [video](https://www.youtube.com/watch?v=KhGnYWplLVo&ab_channel=TechDecodeTutorials)

# Common Errors

## What are Compiler Errors?

1. Syntax Errors: Something is wrong with your code structure.
2. Semantic Errors: Something is wrong with your logic.

In Visual Studio Code, the section "Problems" will help catch these Syntax Errors since it is actively scanning your code and checking to see you are following the conventions/rules.

## What are Compiler Warning?

Same as above, Visual Studio Code has the section called "Problems" that shows you any errors/warnings in real time so that you can fix them BEFORE you run your program. However, the difference here is that the compiler can still compile your code so it's not an error but rather a warning.

Most common, you might see compiler waning about "uninitialized" variables. This just means, you forgot to define what that variable value is. For example, the code below is going to print `favorite_number` but I never define what `favorite_number` is so, we get a compiler warning.

## "Uninitialized Variable" Compiler Warning

```c++

#include <iostream>

int main() {

    int favorite_number; 

    std::cout << favorite_number << std::endl;

    return 0;
}
```

When we run this, the terminal shows favorite_number =`176267360` which is just some random number that was compiled.

## "set but not used" Compiler Warning

You can also define a variable, give it a value but then forget to use it. This is also another common type of compiler warning and it will show up as "<variable_name> set but not used."

```c++
#include <iostream>

int main() {

    int favorite_number; 
    favorite_number = 1000;

    std::cout << "Hello World!" << std::endl;

    return 0;
}
```

The main idea and philosphy behind compiler warnings is that you should have none after you compile your code.

## What are Linker Errors?

Typically, this error occurs when a libary or object file is missing.

Think of this scenario:

* You need file_1, file_2 and file_3 to run your program.

If file_3 references something that is in file_1 or file_2 but they are deleted then you will most likely get a Linker Error.

## What are RunTime Errors?

Errors that occur when the program is executing.

Common RunTime Errors:

* Divide by Zero
* File note Found
* Out of Memory

You typically handle these errors by using `Exception Handling` which is a way to "anticipate" an error and give your program instructions on how to handle an error that might occur.

## What are LogicErrors?

LogicErrors are errors/bugs in your code that cause your programm to run incorrectly. This type of error is caused by the Programmer's logic, how you are trying to solve the problem presented.

# Structure of a C++ Program

## Basic Components (Basic Components create syntax)

* C++ has defined "keywords" which are reserved for the program. This means they are not available for re-defining and/or overloading.

* The `>>` and `<<` are called chevron keys.
* `>>` is called the "string extraction" operator; it takes something from the console and stores it to a variable.
* `<<` is called the "string insertion" operator. We insert whatever is on the right hand side to whatever is on the left.
* `::` is called the scope resolution operator.

## Preprocessor Directives

Preprocessor directives perform preliminary operations on C++ files before they are passed to the compiler. Some use-case examples are inserting files, specifying compile-time error message, defining conditional compilation conditions based on OS etc.

## The Main Function

The `main()` function must always return an integer. A zero 0 is returned when the program runs sucessfully.

The `main()` function represents the starting point of our program execution.

## Namespace

Namespace: the variables defined in C++; "standard variables" means they already have a specific meaning. For example, `cout` means "c out".

`std` is the name for the standard C++ namespace.

So, we know we can use `std::cout <<"Hello World" << std::endl;` to print out "Hello world" in the terminal. But what if we wanted to define our own `cout` function?

`baker::cout`

Now, C++ will be confused because there are two `cout` functions being called. This is why we use `std::` because we are telling the compiler "use the standard namespace that C++ knows when you run the cout function."

`::` this is called the "scope resolution operator" because it's used to define what scope the compiler should use when reading variables/commands.

We can explicitly define what namespace we want the compiler use by defining it before our main() function. This is called using the "namespace directive." For example:

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using namespace std;

int main()
{

    /* Creating variable to store user input*/
    int favorite_number;

    /* Prompt user to enter their favorite number */
    cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    cin >> favorite_number;

    /* Responde back to user */
    cout << "Nice! That's my favorite number too! " << endl;
    cout << "No really! " << favorite_number << " is my favorite number! " << endl;

    return 0;
}
```

This lets us type less and makes the code a little bit easier to read.

However, using the namespace directive bring in EVERYTHING from the `std` (standard namespace) so, more often we will see individual namespaces declared. This means you only declare "what" from the standard namespace you want to the compiler to reference.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 standard scope resolutions
using std::endl;

int main()
{

    /* Creating variable to store user input*/
    int favorite_number;

    /* Prompt user to enter their favorite number */
    cout << "Enter your favorite number from 1 to 100: ";

    /* Capture user input */
    cin >> favorite_number;

    /* Responde back to user */
    cout << "Nice! That's my favorite number too! " << endl;
    cout << "No really! " << favorite_number << " is my favorite number! " << endl;

    return 0;
}
```

## Comments

Comments need to add meaning; do not state the obvious. Before writting comments ask yourself "is this providing any value?" Once thing to note is that comments never make it to the compiler. Preprocessors strip out comments so compiler never sees them. Think about this, why?

Well, comments are for humans, so the compiler does not need this "for human" code in order to compile.

Type of comments:

1. Single Line comments: `// This is an inline comment.`

2. Multiline Comment: `/* */`

## Basic I/O

I/O stands for Input/Output.

* We output to the console using `cout <<`.
  * anything on the right of `cout <<`  is sent to the console.
  * ex. `count << "Hello World";`
  * We can "chain" `cout`; we saw this in the "enter your favorite number" example.
  * ex. `cout << "No really! " << favorite_number << " is my favorite number! " << endl;`
  * Why do we commonly see `endl`? because line breaks are not automatically added
* We input (take in) information from the user using `cin >>`.
  * The information that is inputted is saved to the variables on the right of `cin >>`.
  * This process can also be chained. `cin >> data1 >> data2` This means, whatever is typed in the keyboard is going to be stored in both data1 and data2.
  * We can get fails if the information being inputted is not the type we expected (defined).

A simple example of I/O (Input/Output) is asking for two numbers and storing them.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{

    int number1;
    int number2;

    cout << "Enter a number from 1 - 100: ";

    cin >> number1;

    cout << "Enter another number from 1 - 100: ";

    cin >> number2;

    cout << "You entered " << number1 << " and " << number2 << endl;

    return 0;
}
```

We can also see how c++ ignores whitespace by taking in both numbers at the same time.

So now, when we enter "12 23" 12 will be assigned to `number1` and 23 will be assigned to `number2`. All in one command! Keep in mind that the space between 12 and 23 is important because c++ compiler looks for it to see where your favorite number/input starts and ends.

```c++
/* Ask user to enter number from 1-100 */

#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{

    int number1;
    int number2;

    cout << "Enter two numbers from 1 - 100 seperated by a space: ";

    cin >> number1 >> number2;

    cout << "You entered " << number1 << " and " << number2 << endl;

    return 0;
}
```

# Variables and Constants

## What are variables?

* Variables are abstractions for a memory location.
* In Python, we've seen how a variable is simply a memory locations; the same applies in C++.
* All variables must have a type and value.
* IMPORTANT: variables must be declared before they are used. (This is called static typing)

<dl>
  <dt>Static Typing: </dt>
  <dd>A coding language where VARIABLE TYPES are known at compile time.</dd>
</dl>

```c++
#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{
    int number1;
    number1 = 23;
    return 0;
}
```

Compare the code above with this example:

```c++
#include <iostream>

using std::cin;
using std::cout; // using only these 3 defined standard namespace functions
using std::endl;

int main()
{
    number1 = 23;
    return 0;
}
```

Here, we will get a compiler error becuase we didn't define the variable `type`. The compiler doesn't know if numer1 is suppose to be a character, integer, float etc. In other coding languages, this is not the case. In Python, we can simply declare `age = 23` but not in C++.

## How to declare and initialize a variable

Each variable is created using `VariableType VariableName;`.

What kind of variable types exist?

1. integer `int`
2. double `double` (decimal numbers)
3. string `string` (text)
4. Object Orriented Variables `OOP_Var` ex. `Person`, `Account`

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Enter the width of the room: ";
    int room_width;
    cin >> room_width;

    cout << "Enter the length of the room: ";
    int room_length;
    cin >> room_length;

    cout << "The area of the room is: " << room_width * room_length << " square feet" << endl;

    return 0;
}
```

## Primative Data Types

* The `char` (character) data type must use single quotes when declaring. `char middle_initial = 'J';`
* `unsigned int` are positive numbers and zero.
* `float` data type will hold decimal numbers.
* `double` is for large decimal numbers.
* `long double` is for numbers that use `e` powers.
* `bool` is for True/False values. `True = 1`; `False = 0`.

Note: In C++, if we aren't using C++11 compiler or newer, we will not see overflow errros and instead get inaccurate integer representations.

Overflow is when a variables being declared does not have enough storage to store the initialized variable. Be careful when doing calculations! Think about two `short * short` integers being multipled. The answer will not fit into a `short` so we have to declare it using a different data type.

## What is the size of a variable (sizeof)

The `sizeof` operator determines the size in bytes of a type or variable.

`sizeof` uses the `climits` and `cfloat` include files to provide size and precision about our varibles.

```c++
#include <iostream>
#include <climits>
```

## What is a Constant?

Constants are variables that cannot change once declared.

The most common way of declaring a constant is by using the `const` keyword followed by the name of the constant and the value. Constants must be initialized, meaning they must be given their value. For example, `const int months = 12;` shows the constant "months" having the value 12 since there will always be 12 months in a year.

Another "older" way of defining constants is by using `#define` but this is an old way and should no longer be used in Modern c++ compilers.

Here we have an example of a program that uses literal constants:

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Welcome to Baker's Cleaning Service" << endl;

    cout << "\nEnter the number of rooms you want cleaned: ";
    int number_of_rooms;
    cin >> number_of_rooms;

    cout << "\nEstimate of Cleaning Service: " << endl;
    cout << "Number of rooms: " << number_of_rooms << endl;
    cout << "Price per room $" << 30 << endl;
    cout << "Cost $" << 30 * number_of_rooms << endl;
    cout << "Tax $" << 30 * number_of_rooms * 0.06 << endl;
    cout << "==========================" << endl;
    cout << "Total Estimate: $" << (30 * number_of_rooms) + (30 * number_of_rooms * 0.06) << endl;
    cout << "This estimate is valid for " << 30 << " days" << endl;
    return 0;
}
```

Major disadvantages:

1. If you change your price per room you will have to go into the code and change every "30" to a new price.
2. It is harder to maintain and make changes.

Here is an example of the same program using declared constants. Doing this type of change, where you go into your code and make it better to read is called "refactoring." Rememeber, refactoring is simply making your code easier to read. It is not changing the logic etc.

```c++
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main()
{

    cout << "Welcome to Baker's Cleaning Service" << endl;

    cout << "\nEnter the number of rooms you want cleaned: ";
    int number_of_rooms;
    cin >> number_of_rooms;

    const double price_per_room = 30.0; // use double because maybe you want to charge $30.5 per room 
    const double tax_rate = 0.06;
    const int days_valid = 30; // use int because days will always be whole numbers

    cout << "\nEstimate of Cleaning Service: " << endl;
    cout << "Number of rooms: " << number_of_rooms << endl;
    cout << "Price per room $" << price_per_room << endl;
    cout << "Cost $" << price_per_room * number_of_rooms << endl;
    cout << "Tax $" << price_per_room * number_of_rooms * tax_rate << endl;
    cout << "==========================" << endl;
    cout << "Total Estimate: $" << (price_per_room * number_of_rooms) + (price_per_room * number_of_rooms * tax_rate) << endl;
    cout << "This estimate is valid for " << days_valid << " days" << endl;
    return 0;
}

```

Notice how our `cout` statements are much easier to read and we can follow along and "read" what each statement should be printing out to the console. Also, if we want to change `price_per_room`, `tax_rate` or `days_valid` the change will only have to be made in one place.

### Challenge: Enter the number of small and large rooms and return a total cleaning price
